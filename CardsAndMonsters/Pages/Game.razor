@page "/play"
@layout EmptyLayout

@if (!GameEnded)
{
<div class="container-fluid">
    <div class="opponent-display">
        <div class="row">
            <div class="col-10">
                <PlayerHand Cards="Opponent.CurrentHand" HideInfo />
            </div>
            <div class="col-2">
                <h3 class="text-right">Opponent - @Opponent.HP</h3>
                <DeckPreview DeckCount="Opponent.Deck.Count" />
            </div>
        </div>
    </div>
</div>

<div class="container-fluid">
    <div class="row">
        <div class="col-2">
            <h3 class="text-left">Turn: @(TurnCount + 1) (@CurrentTurn.Phase)</h3>
            @if (CurrentTurn.IsCurrentPlayer(Player))
            {
                @if (CurrentTurn.Phase < Phase.Battle)
                {
                    <button class="btn" @onclick="() => EnterPhase(Phase.Battle)">BATTLE</button>
                }
                <button class="btn" @onclick="EndTurn">END TURN</button>
            }
            else
            {
                <button class="btn" @onclick="EndTurn">END OPPONENTS TURN</button>
            }
        </div>
        <div class="col-9">
            <GameBoard CurrentTurn="CurrentTurn" Turns="Turns" Board="Board" OnPlayerAttack="Attack" OnPositionSwitch="PositionSwitched"/>
        </div>
        <div class="col-1">
        </div>
    </div>
</div>

<div class="container-fluid">
    <div class="player-display">
        <div class="row">
            <div class="col-2">
                <h3 class="text-left">You - @Player.HP</h3>
                <DeckPreview DeckCount="Player.Deck.Count" />
            </div>
            <div class="col-10">
                <PlayerHand Cards="Player.CurrentHand" CanPlay="CanPlay()" CardPlayed="PlayCard" Phase="CurrentTurn.Phase"/>
            </div>
        </div>
    </div>
</div>
<SelectCardPosition CardPendingPlacement="PendingPlacement" DisplayOptions="ChoosingFieldPosition" OnPositionPicked="PlayMonster"/>
}
else
{
    <h3 class="text-center">Game Over</h3>
}

@code {
    private Player Player;
    private Player Opponent;

    private Board Board;
    private IDictionary<int, TurnState> Turns;
    private TurnState CurrentTurn;

    private Player StartingPlayer;
    private bool ChoosingFieldPosition;
    private bool GameEnded;

    protected override async Task OnInitializedAsync()
    {
        Turns = new Dictionary<int, TurnState>();

        Player = PlayerBuilder.GetNewPlayer();
        Opponent = PlayerBuilder.GetNewOpponent();
        Board = new(Player, Opponent);

        Random rnd = new();
        StartingPlayer = rnd.Next(2) == 1 ? Opponent : Player;
        CurrentTurn = new(StartingPlayer);

        EnterPhase(Phase.Standby);
        StateHasChanged();

        for (int i = 0; i < 5; i++)
        {
            Opponent.DrawCard();
            Player.DrawCard();
            StateHasChanged();
            await Task.Delay(300);
        }

        StartTurn(StartingPlayer, false);
    }

    private int TurnCount = 0;

    private bool CanPlay()
    {
        return CurrentTurn.IsCurrentPlayer(Player) && (CurrentTurn.Phase is Phase.Main && !ChoosingFieldPosition || (CurrentTurn.Phase is Phase.Battle && TurnCount > 0));
    }

    private void StartTurn(Player player, bool drawCard)
    {
        var isPlayer = Player.Equals(player);
        CurrentTurn = new(isPlayer ? Board.PlayerMonsters : Board.OpponentMonsters, player);

        if (drawCard)
        {
            var success = player.DrawCard();
            if (!success)
            {
                EndGame();
                return;
            }
        }

        EnterPhase(Phase.Main);

        if (!isPlayer)
        {
            FakeOpponentsTurn();
        }
    }

    private void FakeOpponentsTurn()
    {
        foreach(var monster in Board.OpponentMonsters)
        {
            monster.FieldPosition = NewPosition(monster.FieldPosition);
            CurrentTurn.MonsterState[monster.Id].AbleToSwitch = false;
        }

        Random rnd = new();

        var card = Opponent.CurrentHand[rnd.Next(Opponent.CurrentHand.Count)];
        if (card.IsType(typeof(Monster)) && Board.OpponentMonsters.Count < 5)
        {
            var monster = card as Monster;
            monster.FieldPosition = rnd.Next(2) == 1 ? FieldPosition.VerticalUp : FieldPosition.HorizontalDown;
            Opponent.PlayMonster(monster, Board, CurrentTurn);

            if (TurnCount == 0)
            {
                CurrentTurn.MonsterState[monster.Id].TimesAttacked = monster.AttacksPerTurn;
            }
        }

        EnterPhase(Phase.Battle);

        EndTurn();
    }

    private FieldPosition NewPosition(FieldPosition old)
    {
        return old switch
        {
            FieldPosition.HorizontalUp => FieldPosition.VerticalUp,
            FieldPosition.HorizontalDown => FieldPosition.VerticalUp,
            FieldPosition.VerticalUp => FieldPosition.HorizontalUp,
            FieldPosition.VerticalDown => FieldPosition.VerticalUp,
            _ => throw new IndexOutOfRangeException("couldn't work out the new position")
        };
    }

    private void EnterPhase(Phase phase)
    {
        CurrentTurn.Phase = phase;
    }

    private void EndTurn()
    {
        EnterPhase(Phase.End);
        Turns[TurnCount] = CurrentTurn;
        TurnCount++;
        EnterPhase(Phase.Standby);
        StartTurn(Turns.Last().Value.Player.Equals(Player) ? Opponent : Player, true);
    }

    private void PlayCard(BaseCard card)
    {
        if (card.IsType(typeof(Monster)))
        {
            var monster = card as Monster;
            if (CurrentTurn.IsCurrentPlayer(Player))
            {
                if (Board.PlayerMonsters.Count == 5 || CurrentTurn.NormalSummonLimitReached())
                {
                    return;
                }

                PlayMonster(monster);
            }
        }
    }

    private BaseCard PendingPlacement;
    private void PlayMonster(Monster monster)
    {
        ChoosingFieldPosition = true;
        PendingPlacement = monster;
    }

    private void PlayMonster(FieldPosition position)
    {
        ChoosingFieldPosition = false;
        var monster = PendingPlacement as Monster;
        monster.FieldPosition = position;
        Player.PlayMonster(monster, Board, CurrentTurn);
        if (TurnCount == 0)
        {
            CurrentTurn.MonsterState[monster.Id].TimesAttacked = monster.AttacksPerTurn;
        }
        PendingPlacement = null;
    }

    private void Attack(BattleInfo battleInfo)
    {
        switch (battleInfo.Target)
        {
            case BattleTarget.Direct:
                {
                    if (Board.OpponentMonsters.Any())
                    {
                        throw new InvalidOperationException("Cannot attack directly if opponent has monsters");
                    }
                    else
                    {
                        DirectAttack(battleInfo.AttackingMonster, battleInfo.DefendingPlayer);
                    }
                    break;
                }
            case BattleTarget.Monster:
                {
                    MonsterAttack(battleInfo);
                    break;
                }
            default:
                break;
        }
    }

    private void MonsterAttack(BattleInfo battleInfo)
    {
        switch (battleInfo.TargetMonster.FieldPosition)
        {
            case FieldPosition.HorizontalUp:
                {
                    battleInfo.TargetMonster.FieldPosition = NewPosition(battleInfo.TargetMonster.FieldPosition);
                    CalculateAtkVsDef(battleInfo);
                }
                break;
            case FieldPosition.HorizontalDown:
                {
                    CalculateAtkVsDef(battleInfo);
                }
                break;
            case FieldPosition.VerticalUp:
                {
                    CalculateAtkVsAtk(battleInfo);
                }
                break;
            default:
                break;
        }
    }

    private void CalculateAtkVsAtk(BattleInfo battleInfo)
    {
        if (battleInfo.AttackingMonster.Attack > battleInfo.TargetMonster.Attack)
        {
            DestroyMonster(battleInfo.TargetMonster, battleInfo.DefendingPlayer);
            decimal dmg = battleInfo.AttackingMonster.Attack - battleInfo.TargetMonster.Attack;
            DamageDuelist(battleInfo.DefendingPlayer, dmg);
        }
        else if (battleInfo.AttackingMonster.Attack == battleInfo.TargetMonster.Attack)
        {
            DestroyMonster(battleInfo.AttackingMonster, battleInfo.AttackingPlayer);
            DestroyMonster(battleInfo.TargetMonster, battleInfo.DefendingPlayer);
        }
        else
        {
            DestroyMonster(battleInfo.AttackingMonster, battleInfo.AttackingPlayer);
            decimal dmg = battleInfo.TargetMonster.Attack - battleInfo.AttackingMonster.Attack;
            DamageDuelist(battleInfo.AttackingPlayer, dmg);
        }
    }

    private void CalculateAtkVsDef(BattleInfo battleInfo)
    {
        if (battleInfo.AttackingMonster.Attack > battleInfo.TargetMonster.Defense)
        {
            DestroyMonster(battleInfo.TargetMonster, battleInfo.DefendingPlayer);
        }
        else if (battleInfo.AttackingMonster.Attack < battleInfo.TargetMonster.Defense)
        {
            DestroyMonster(battleInfo.AttackingMonster, battleInfo.AttackingPlayer);
            decimal dmg = battleInfo.TargetMonster.Defense - battleInfo.AttackingMonster.Attack;
            DamageDuelist(battleInfo.AttackingPlayer, dmg);
        }
    }

    private void DestroyMonster(Monster monster, Player player)
    {
        if (Player.Equals(player))
        {
            Board.PlayerMonsters.Remove(monster);
            if (CurrentTurn.Player.Equals(Player))
            {
                MarkAsDestroyed(monster.Id);
            }
        }
        else
        {
            Board.OpponentMonsters.Remove(monster);
            if (CurrentTurn.Player.Equals(Opponent))
            {
                MarkAsDestroyed(monster.Id);
            }
        }
    }

    private void MarkAsDestroyed(Guid monsterId)
    {
        CurrentTurn.MonsterState[monsterId].Destroyed = true;
    }

    private Player OtherPlayer()
    {
        return CurrentTurn.Player.Equals(Player) ? Opponent : Player;
    }

    private void DirectAttack(Monster monster, Player player)
    {
        CurrentTurn.MonsterState[monster.Id].TimesAttacked++;
        DamageDuelist(player, monster.Attack);
    }

    private void PositionSwitched(Monster monster)
    {
        var currentMonster = Board.PlayerMonsters.FirstOrDefault(m => m.Equals(monster));
        Board.PlayerMonsters[Board.PlayerMonsters.IndexOf(currentMonster)] = monster;
        CurrentTurn.MonsterState[monster.Id].AbleToSwitch = false;
    }

    private void DamageDuelist(Player player, decimal dmg)
    {
        if (player.Equals(Player))
        {
            DamagePlayer(dmg);
        }
        else
        {
            DamageOpponent(dmg);
        }
    }

    private void DamageOpponent(decimal amount)
    {
        Opponent.TakeDamage(amount);
        CheckForGameOver();
    }

    private void DamagePlayer(decimal amount)
    {
        Player.TakeDamage(amount);
        CheckForGameOver();
    }

    private void CheckForGameOver()
    {
        if (Player.OutOfHealth() || Opponent.OutOfHealth())
        {
            EndGame();
        }
    }

    private void EndGame()
    {
        GameEnded = true;
    }
}

<style>
    .opponent-display {
        margin-bottom: 1em;
    }
    .player-display {
        margin-top: 1em;
    }

    .spell-row, .monster-row {
        display: flex;
        justify-content: space-between;
    }
</style>