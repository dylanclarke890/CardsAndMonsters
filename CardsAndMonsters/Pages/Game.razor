@page "/play"
@layout EmptyLayout
@inject IGameOverService _gameOverService
@inject IBattleService _battleService
@inject IPositionService _positionService
@inject IPhaseService _phaseService
@inject ITurnService _turnService
@inject IFakeOpponentService _fakeOpponentService;

@if (!_gameOverService.GameOver)
{
    <OpponentView Opponent="Board.Opponent" />

    <div class="container-fluid">
        <div class="row">
            <div class="col-1">
                <TurnInfoDisplay Board="Board" />
            </div>
            <div class="col-10">
                <CascadingValue Value="Board" TValue="Board">
                    <CardField OnPlayerAttack="Attack" OnPositionSwitch="SwitchPosition" />
                </CascadingValue>
            </div>
        </div>
    </div>
    <CascadingValue Value="Board" TValue="Board">
        <PlayerView PendingPlacement="PendingPlacement" CardPlayed="PlayCard" DisplayFieldOptions="ChoosingFieldPosition"
                    OnPositionPicked="PlayMonster" />
    </CascadingValue>
}
<GameOver Player="Board.Player" />

@code {
    private Board Board;
    private bool ChoosingFieldPosition;
    private BaseCard PendingPlacement;

    protected override async Task OnInitializedAsync()
    {
        Board = new(DuelistBuilder.GetNewPlayer(), DuelistBuilder.GetNewOpponent());

        Random rnd = new();
        var startingPlayer = rnd.Next(2) == 1 ? Board.Opponent : Board.Player;
        Board.CurrentTurn = new(startingPlayer);

        _phaseService.EnterPhase(Phase.Standby, Board);
        StateHasChanged();

        for (int i = 0; i < AppConstants.HandSize; i++)
        {
            Board.Opponent.DrawCard();
            Board.Player.DrawCard();
            StateHasChanged();
            await Task.Delay(300);
        }

        _turnService.StartTurn(startingPlayer, false, Board);

        if (!startingPlayer.Equals(Board.Player))
        {
            _fakeOpponentService.FakeOpponentsTurn(Board);
        }
    }

    private void PlayCard(BaseCard card)
    {
        if (card.IsType(typeof(Monster)))
        {
            var monster = card as Monster;
            if (Board.Player.Equals(Board.CurrentTurn.Player))
            {
                if (Board.PlayerMonsters.Count == AppConstants.FieldSize || Board.CurrentTurn.NormalSummonLimitReached())
                {
                    return;
                }

                PlayMonster(monster);
            }
        }
    }

    private void PlayMonster(Monster monster)
    {
        ChoosingFieldPosition = true;
        PendingPlacement = monster;
    }

    private void PlayMonster(FieldPosition position)
    {
        ChoosingFieldPosition = false;
        var monster = PendingPlacement as Monster;
        monster.FieldPosition = position;
        Board.Player.PlayMonster(monster, Board, Board.CurrentTurn);
        if (Board.TurnCount == 0)
        {
            Board.CurrentTurn.MonsterState[monster.Id].TimesAttacked = monster.AttacksPerTurn;
        }
        PendingPlacement = null;
    }

    private void Attack(BattleInfo battleInfo)
    {
        _battleService.Attack(battleInfo);
        _gameOverService.CheckForGameOver(Board);
    }

    private void SwitchPosition(Monster monster)
    {
        monster.FieldPosition = _positionService.NewPosition(monster.FieldPosition);
        _positionService.PositionSwitched(monster, Board);
    }
}

<style>
    .opponent-display {
        margin-bottom: 1em;
    }

    .player-display {
        margin-top: 1em;
    }

    .spell-row, .monster-row {
        display: flex;
        justify-content: space-between;
    }
</style>