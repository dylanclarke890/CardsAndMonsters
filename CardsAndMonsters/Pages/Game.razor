@page "/play"
@layout EmptyLayout
@inject IBattleService _battleService 
@inject IPositionService _positionService

@if (!GameEnded)
{
    <OpponentView Opponent="Board.Opponent" />

    <div class="container-fluid">
        <div class="row">
            <div class="col-1">
                <h3>@(TurnCount + 1)</h3>
                <h3>@Board.CurrentTurn.Phase</h3>
                @if (Board.Player.IsCurrentPlayer(Board.CurrentTurn.Player))
                {
                    @if (Board.CurrentTurn.Phase < Phase.Battle)
                    {
                        <button class="btn btn-outline-primary" @onclick="() => EnterPhase(Phase.Battle)">BATTLE</button>
                    }
                    <button class="btn btn-outline-primary" @onclick="EndTurn">END</button>
                }
            </div>
            <div class="col-10">
                <CascadingValue Value="Board" TValue="Board">
                    <CardField OnPlayerAttack="Attack" OnPositionSwitch="SwitchPosition"/>
                </CascadingValue>
            </div>
        </div>
    </div>
    <CascadingValue Value="Board" TValue="Board">
        <PlayerView PendingPlacement="PendingPlacement" CardPlayed="PlayCard" DisplayFieldOptions="ChoosingFieldPosition"
                    OnPositionPicked="PlayMonster" />
    </CascadingValue>
}
else
{
    <GameOver LosingPlayer="LosingPlayer" Player="Board.Player" LossReason="Reason" />
}

@code {
    private Board Board;
    private bool ChoosingFieldPosition;
    private bool GameEnded;
    private int TurnCount = 0;
    private BaseCard PendingPlacement;
    private Player LosingPlayer;
    private LossReason Reason;

    protected override async Task OnInitializedAsync()
    {
        Board = new(PlayerBuilder.GetNewPlayer(), PlayerBuilder.GetNewOpponent());

        Random rnd = new();
        var startingPlayer = rnd.Next(2) == 1 ? Board.Opponent : Board.Player;
        Board.CurrentTurn = new(startingPlayer);

        EnterPhase(Phase.Standby);
        StateHasChanged();

        for (int i = 0; i < AppConstants.HandSize; i++)
        {
            Board.Opponent.DrawCard();
            Board.Player.DrawCard();
            StateHasChanged();
            await Task.Delay(300);
        }

        StartTurn(startingPlayer, false);
    }

    private void StartTurn(Player player, bool drawCard)
    {
        bool isPlayer = Board.Player.Equals(player);
        Board.CurrentTurn = new(isPlayer ? Board.PlayerMonsters : Board.OpponentMonsters, player);

        if (drawCard)
        {
            var success = player.DrawCard();
            if (!success)
            {
                EndGame(player, LossReason.DeckOut);
                return;
            }
        }

        EnterPhase(Phase.Main);

        if (!isPlayer)
        {
            FakeOpponentsTurn();
        }
    }

    private void EnterPhase(Phase phase)
    {
        Board.CurrentTurn.Phase = phase;
    }

    private void EndTurn()
    {
        EnterPhase(Phase.End);
        Board.Turns[TurnCount] = Board.CurrentTurn;
        TurnCount++;
        EnterPhase(Phase.Standby);
        StartTurn(Board.Turns.Last().Value.Player.Equals(Board.Player) ? Board.Opponent : Board.Player, true);
    }

    private void PlayCard(BaseCard card)
    {
        if (card.IsType(typeof(Monster)))
        {
            var monster = card as Monster;
            if (Board.Player.Equals(Board.CurrentTurn.Player))
            {
                if (Board.PlayerMonsters.Count == AppConstants.FieldSize || Board.CurrentTurn.NormalSummonLimitReached())
                {
                    return;
                }

                PlayMonster(monster);
            }
        }
    }

    private void PlayMonster(Monster monster)
    {
        ChoosingFieldPosition = true;
        PendingPlacement = monster;
    }

    private void PlayMonster(FieldPosition position)
    {
        ChoosingFieldPosition = false;
        var monster = PendingPlacement as Monster;
        monster.FieldPosition = position;
        Board.Player.PlayMonster(monster, Board, Board.CurrentTurn);
        if (TurnCount == 0)
        {
            Board.CurrentTurn.MonsterState[monster.Id].TimesAttacked = monster.AttacksPerTurn;
        }
        PendingPlacement = null;
    }

    private void Attack(BattleInfo battleInfo)
    {
        _battleService.Attack(battleInfo);
        CheckForGameOver();
    }

    private void SwitchPosition(Monster monster)
    {
        monster.FieldPosition = _positionService.NewPosition(monster.FieldPosition);
        _positionService.PositionSwitched(monster, Board);
    }

    private void CheckForGameOver()
    {
        if (Board.Player.OutOfHealth())
        {
            EndGame(Board.Player, LossReason.NoHP);
        }
        if (Board.Opponent.OutOfHealth())
        {
            EndGame(Board.Opponent, LossReason.NoHP);
        }
    }

    private void EndGame(Player player, LossReason reason)
    {
        Reason = reason;
        LosingPlayer = player;
        GameEnded = true;
    }

    private void FakeOpponentsTurn()
    {
        foreach(var monster in Board.OpponentMonsters)
        {
            monster.FieldPosition = _positionService.NewPosition(monster.FieldPosition);
            Board.CurrentTurn.MonsterState[monster.Id].AbleToSwitch = false;
        }

        Random rnd = new();

        var card = Board.Opponent.CurrentHand[rnd.Next(Board.Opponent.CurrentHand.Count)];
        if (card.IsType(typeof(Monster)) && Board.OpponentMonsters.Count < AppConstants.FieldSize)
        {
            var monster = card as Monster;
            monster.FieldPosition = rnd.Next(2) == 1 ? FieldPosition.VerticalUp : FieldPosition.HorizontalDown;
            Board.Opponent.PlayMonster(monster, Board, Board.CurrentTurn);

            if (TurnCount == 0)
            {
                Board.CurrentTurn.MonsterState[monster.Id].TimesAttacked = monster.AttacksPerTurn;
            }
        }

        EnterPhase(Phase.Battle);

        EndTurn();
    }
}

<style>
    .opponent-display {
        margin-bottom: 1em;
    }
    .player-display {
        margin-top: 1em;
    }

    .spell-row, .monster-row {
        display: flex;
        justify-content: space-between;
    }
</style>